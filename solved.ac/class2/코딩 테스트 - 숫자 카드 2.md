## 목차

1. 문제
2. 문제 해결 과정
	-  2-1. 초기 구현 및 통과
	-  2-2. 시간 초과에 대한 문제점
	-  2-3. 성능 개선
3. 타인 코드 분석
4. 소감

###### 1.문제 내용

<img width="1132" height="806" alt="Image" src="https://github.com/user-attachments/assets/6609d89d-88ec-4db0-9b47-1b711a3a9aaa" />

###### 2.해결 과정

2-1.초기 구현 및 통과

<img width="1427" height="432" alt="Image" src="https://github.com/user-attachments/assets/ab9ca60b-eeab-4896-8f2d-eee8fbc36e92" />

우선은 이 문제의 요구 사항을 정리를 해보면 아래와 같습니다.

- 첫 번째 배열: 입력한 수만큼 중복된 임의의 수를 넣는다.
- 첫 번째 배열의 숫자 빈도를 미리 계산한다.
- 두 번째 배열: 입력한 수만큼 중복되지 않는 임의의 수를 넣는다.
- 두 번째 배열의 각 숫자에 대해, 첫 번째 배열에서의 등장 횟수를 조회하여 출력한다.
- 두 번째 배열의 숫자에서 첫 번째 배열의 숫자가 없으면 0으로 출력

문제를 푸는 핵심은 **중복된 숫자의 개수를 효율적으로 계산하는 방법**입니다. 모든 숫자를 직접 비교하는 방식은 비효율적이므로, 빈도를 미리 저장한 뒤 조회하는 방식이 필요했다.

이를 위해서 `int` 타입 변수 여러 개나 단순 배열 대신 `Map<Integer, Integer>`을 선택한 이유는 다음과 같습니다.

- 효율적인 탐색 속도
    단순 배열이나 리스트에서 특정 숫자를 찾으려면 최악의 경우 전체를 다 훑어야 하는 $O(N)$의 시간이 걸립니다. 하지만 HashMap은 해시 함수를 통해 데이터의 위치를 바로 찾기 때문에, 평균적으로 **$O(1)$**의 시간 안에 카운트 값을 가져올 수 있습니다.
- 가독성 및 유지 보수성
    `getOrDefault(key, 0) + 1`과 같은 내장 메서드를 활용하면, 데이터의 존재 여부를 체크하고 카운팅하는 복잡한 조건문을 단 한 줄의 직관적인 코드로 대체할 수 있습니다.

알고리즘의 순서는 아래와 같습니다.

- Scanner 를 사용해서 입력값을 받는다. 
- 첫번째 배열 arr1을 생성하고 반복문을 돌려서 값을 넣는다.
- HashMap을 사용해서 arr1에서 배열의 빈도값을 저장한다.
- 두번째 배열 arr2를 생성하고 반복문을 돌려서 값을 넣는다.
- arr2를 돌리면서 map에 저장된 빈도수를 체크를 하고 

알고리즘을 바탕으로 한 초기 구현의 도식과 코드는 아래와 같습니다.

<img width="1822" height="1940" alt="Image" src="https://github.com/user-attachments/assets/8179b7d9-5b33-4097-9392-005218af60a4" />

```
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		// 첫번째 수
		int number1 = sc.nextInt();
		// 첫번째 배열생성
		int[]arr1 = new int[number1];
		// 첫번째 배열 반복문에 넣기.
		for(int i =0; i<arr1.length;i++) {
			arr1[i] = sc.nextInt();
		}
		// 첫번째 배열에서 같은 숫자의 빈도를 넣기위해서 map을 사용
		Map<Integer,Integer>map = new HashMap<>();
		
		for(int num : arr1) {
			map.put(num, map.getOrDefault(num, 0)+1);
		}

		// 두번째 수
		int number2 = sc.nextInt();
		// 두번째 배열생성
		int[]arr2 = new int[number2];
		// 배열 반복문에 넣기
		for(int j=0; j<arr2.length;j++) {
			arr2[j] = sc.nextInt();
		}

		// 두번째 배열에 있는 숫자와 비교를 해서 빈도수를 StringBuilder를 사용해서 공백을 사용해서 
		// 넣기
		StringBuilder sb = new StringBuilder();
        for (int target : arr2) {
            // HashMap의 getOrDefault를 사용하면 if(null) 체크 없이 한 줄로 가능합니다.
            sb.append(map.getOrDefault(target, 0)).append(" ");
        }
        // 결과값 출력
        System.out.println(sb.toString().trim());
        
        sc.close();
	}
```

<img width="1422" height="96" alt="Image" src="https://github.com/user-attachments/assets/49041f59-82ce-486c-9823-47af61396474" />

이미지처럼 메모리와 시간을 보면 통과 기준에 간당간당하게 통과된 것을 알 수 있습니다.

2-2. 시간 초과에 대한 문제점

초기 구현은 2228ms로 시간 제한에 간신히 통과한 상태였으며, 반복문 내부에서 `System.out.print()`를 사용하자 즉시 시간 초과가 발생했습니다. 이를 통해 해당 코드는 이미 성능 한계치에 근접해 있었고, 출력 방식과 같은 사소한 구현 차이도 결과에 큰 영향을 미친다는 점을 확인할 수 있었습니다.


<img width="1422" height="134" alt="Image" src="https://github.com/user-attachments/assets/a8954614-35cb-44ef-b4cb-33e3a20e50bd" />

```
import java.util.*;

public class Main {
    
    public static void main(String[]args){
        Scanner sc = new Scanner(System.in);
		
		int number1 = sc.nextInt();
		int[]arr1 = new int[number1];
		for(int i =0; i<arr1.length;i++) {
			arr1[i] = sc.nextInt();
		}
		
		Map<Integer,Integer>map = new HashMap<>();
		
		for(int num : arr1) {
			map.put(num, map.getOrDefault(num, 0)+1);
		}
		
		int number2 = sc.nextInt();
		int[]arr2 = new int[number2];
		
        for(int j=0; j<arr2.length;j++) {
			arr2[j] = sc.nextInt();
		}
		
        for (int target : arr2) {
            System.out.print(map.getOrDefault(target, 0)+" ");
        }
        
        sc.close();

    }
}
```

왜  시간초과가 났는지를 ai에게 물어본 결과 다음과 같은 답변을 알게 되었습니다. 

- **I/O 병목 현상:** `System.out.print()`는 호출될 때마다 즉시 콘솔에 출력하기 위해 시스템 리소스를 사용합니다. 데이터가 50만 건일 경우, 50만 번의 개별적인 출력 요청이 발생하며 컴퓨터 아키텍처 상 매우 느린 작업인 I/O에서 심각한 병목이 발생한 것입니다.
    
- **통과 기준의 임계점:** 최초 통과 시간이 **2228ms**였다는 점을 감안하면, 제 코드는 이미 효율성의 한계치에 아슬아슬하게 걸쳐 있었습니다. 아주 작은 변화(출력 방식 변경)만으로도 1초라는 시간 제한의 벽을 넘지 못하게 된 것입니다.

또한 시간 복잡도의 측면에서의 관점을 다시 문제에서의 입력값을 고려해보도록 하겠습니다. 

- N,M의 입력값의 범위는 각각 최대 500000
- 값의 범위: ±10,000,000

따라서 모든 카드를 비교하는 O(N²) 방식 즉 이중 반복문은 시간 제한을 초과한다. 왜냐하면 N과 M이 각각 최대 500,000이므로, 이중 반복문 방식은 최악의 경우 약 2.5×10¹¹번의 연산이 발생해 시간 제한을 초과한다는 점입니다.

즉, 카드의 빈도를 미리 저장한 뒤 처리하는 방식으로 접근하였고, HashMap을 사용함으로써 각 조회를 평균 O(1)에 수행하여 전체 시간 복잡도를 O(N + M)으로 줄일 수 있었다.

이후 성능 병목의 원인이 알고리즘이 아닌 **입력·출력 처리 방식**에 있음을 확인하였고, `Scanner` 대신 `BufferedReader`를 사용하여 입력 속도를 개선하였다. 또한 출력은 `StringBuilder`에 결과를 누적한 뒤 한 번에 출력하도록 변경하여 불필요한 I/O 호출을 최소화하였다.

2-3. 성능 개선하기

위의 간당간당하게 통과가 되는 코드를 수정을 하기 위해서 수정이 된 부분은 다음과 같습니다.

- Scanner에서 BufferedReader로 변경
- 각 변수를 받는 것을 StringTokenizer로 변경 
- StringBuilder를 사용해서 결과값을 출력

```
import java.util.*;
import java.io.*;

public class Main {
    
    public static void main(String[]args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        int number1 = Integer.parseInt(br.readLine());
        int[] arr1 = new int[number1];

        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < number1; i++) {
            arr1[i] = Integer.parseInt(st.nextToken());
        }

        Map<Integer, Integer> map = new HashMap<>(number1 * 2);
        for (int num : arr1) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }

        int number2 = Integer.parseInt(br.readLine());
        int[] arr2 = new int[number2];

        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < number2; i++) {
            arr2[i] = Integer.parseInt(st.nextToken());
        }

        StringBuilder sb = new StringBuilder(number2 * 2);
        for (int target : arr2) {
            sb.append(map.getOrDefault(target, 0)).append(' ');
        }
        sb.setLength(sb.length() - 1);

        System.out.println(sb);

    }
}
```

<img width="1427" height="432" alt="Image" src="https://github.com/user-attachments/assets/57fe9d42-9c27-4f62-8f7e-0ac0e6d9b6e5" />

결과적으로 실행 시간을 안정적으로 단축할 수 있었으며, 대량의 입력과 출력이 요구되는 문제에서는 I/O 처리 방식 또한 성능의 핵심 요소임을 확인할 수 있습니다. 

###### 3.타인 코드 분석

여러 상위 제출 코드를 분석한 결과, 대부분 다음과 같은 공통점을 가지고 있었다.

- HashMap 대신 **고정 크기 배열**을 사용한 빈도 카운팅
- `System.in.read()` 또는 `DataInputStream` 기반의 **초저수준 입력 처리**
- `BufferedOutputStream` 또는 byte 배열을 활용한 **직접 출력 구현**
- 가독성과 추상화를 포기하고 **I/O 호출 횟수를 최소화**하는 방향의 구현

이러한 코드들은 알고리즘 자체는 O(N + M)으로 동일하지만, Java 표준 입출력 API를 우회하여 **상수 시간(constant factor)**을 극단적으로 줄이는 데 집중한 형태였다

솔직히 말해, 이러한 코드들은 처음 보았을 때 바로 이해하기 어려웠고, 특히 출력 부분은 어떤 의도로 작성되었는지 직관적으로 파악하기 힘들었다.

다만 공통적으로 확인할 수 있었던 점은, 알고리즘 자체의 차이가 아니라 입력·출력 처리 방식과 자료구조 선택에서 성능 차이가 발생한다는 사실이었다.

결과적으로, 상위 제출 코드들은 극단적인 성능을 위해 가독성과 추상화를 포기한 선택이었다고 볼 수 있다. 이러한 구현 방식은 대회 환경에서는 효과적일 수 있으나, 이해 가능성과 설명 가능성을 중시하는 학습 단계에서는 적합하지 않다고 판단했다.

###### 4.소감

이번 문제를 통해 알고리즘의 시간 복잡도뿐만 아니라, 실제 실행 시간에 영향을 미치는 요소가 무엇인지 구분해서 바라보는 시각을 얻었다. 

동일한 O(N + M) 알고리즘이라도 입력·출력 처리 방식에 따라 결과가 크게 달라질 수 있었고, 일반적인 I/O 최적화에는 명확한 성능 한계가 존재한다는 점을 직접 확인했다. 

이를 통해 무조건 빠른 구현을 추구하기보다, 현재 코드가 어디에서 병목이 발생하는지를 판단하고 그에 맞는 수준의 최적화를 선택하는 것이 중요하다는 점을 배웠다.

