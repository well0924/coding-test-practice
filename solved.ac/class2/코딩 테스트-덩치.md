
## 목차

1. 문제 
2. 문제 해결 과정
	- 2-1. 초기 구현 및 1차 통과(Scanner)
	- 2-2. 성능 개선(BufferedReader)
3. 타인 코드 분석 및 리팩토링
4. 소감

1.문제
<img width="717" height="895" alt="Image" src="https://github.com/user-attachments/assets/0cbb219e-e2ad-4e43-b765-2a6720433cdd" />

2.문제 해결 과정

2-1. 초기 구현 및 1차 통과(Scanner)

<img width="1440" height="1920" alt="Image" src="https://github.com/user-attachments/assets/d06b8465-fd12-485c-9a8a-682ed8c3aafe" />

우선 위의 사진은 문제를 보고 손코딩을 한 부분입니다. 이해한 문제의 요구 사항을 정리를 해보면 아래와 같습니다.

- 각 사람은 `(몸무게, 키)` 쌍으로 표현된다.  
- 어떤 사람 A가 사람 B보다 **몸무게도 크고 키도 클 때만** A가 B보다 덩치가 크다고 판단한다.
	- **하나만 크면 인정 안 됨** 
	-  **둘 다 커야 카운트** 

- 모든 사람을 서로 비교해서 **나보다 덩치가 큰 사람이 몇 명인지** 세면 됩니다.
	- 처음 등수는 모두 1로 시작
	- 나보다 덩치 큰 사람이 한 명 발견될 때마다 등수 +1

- 사용할 방법은 Map과 배열을  떠올렸지만 배열을 선택을 했습니다. 
	- 처음에는 사람의 키(Height)를 `Key`로, 몸무게(Weight)를 `Value`로 하는 `Map<Integer, Integer>` 구조를 고려했습니다.
	
	- 그러나 문제 조건상 **키가 동일한 사람이 존재할 가능성**이 있으며, 이 경우 Map의 특성상 동일한 `Key`에 대해 데이터가 덮어 씌워지는 **데이터 정합성 오류**가 발생할 수 있다고 판단했습니다.
	
	- 사람을 식별할 고유 ID가 없는 상태에서 모든 데이터를 안전하게 전수 비교하기 위해, 입력 순서에 따른 인덱스 관리가 용이한 **2차원 배열(`int[][]`)**을 최종 선택했습니다.

- 복잡도 분석 
	- 이 문제에서는 N명의 인원에 대해 이중 반복문을 사용하여 각 사람을 전부 비교를 하므로 $O(N^2)$의 시간 복잡도를 가집니다. 

	- 문제에서 주어진 $N$의 최대치는 50이므로, 최악의 경우에도 약 **2,500번($50 \times 50$)**의 연산이 수행됩니다.    
	- 일반적으로 1초에 약 1억 번의 연산이 가능하다고 가정할 때, $2,500$번의 연산은 제한 시간 대비 매우 적은 수치이므로 $O(N^2)$ 알고리즘으로도 안정적인 통과가 가능하다고 판단했습니다.

- 공간 복잡도 ($O(N)$)
	- N 명의 몸무게와 키 데이터를 저장하기 위해 `int[N][2]` 크기의 2차원 배열을 사용하며, 이는 N에 비례하는 메모리 공간을 소모합니다. 

알고리즘의 수행 순서는 다음과 같습니다.

- Scanner 를 사용해서  입력 값을 받는다.
- 사람들의 `(몸무게, 키)`를 반복문을 사용해서 배열에 저장
- 바깥 반복문: 기준이 되는 사람 i
- 안쪽 반복문: 비교 대상 사람 j
- 이중  반복문의 안쪽 반복문 내부에 조건문을 추가
  ```
  if (weight[j] > weight[i] && height[j] > height[i])
    rank++
  ```
- 최종적으로 rank를 출력을 한다. 

위의 순서를 토대로 한 알고리즘 순서도는 아래와 같습니다.

<img width="1363" height="982" alt="Image" src="https://github.com/user-attachments/assets/85430ae3-73ff-4f8c-a137-aae8be6095e0" />

최종적으로  작성을 한 코드는 아래와 같습니다.

```
Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt();
		// 인원수 배열
		int[][]person = new int[n][2];
		
		// 반복문으로 사람의 키와 몸무게를 넣기.
		for(int i=0;i<n;i++) {
			person[i][0] = sc.nextInt(); // 키
			person[i][1] = sc.nextInt(); // 몸무게
		}
		
		//이중 반복문을 돌리면서 랭킹을 정하기.
		//내부 반복문에서 키와 몸무게가 같으면 continue
		//키나 몸무게 둘 중 하나만 높으면 중복 랭킹으로 하기.
		
		for(int j=0; j<person.length;j++) {
			int rank =1;
			for(int k=0;k<person.length;k++) {
				if(j==k) {
					continue;
				}
				if(person[j][0]<person[k][0]&&person[j][1]<person[k][1]) {
					rank++;
				}
			}
			System.out.print(rank + " ");
		}
		sc.close();
	}
```

이 코드를 제출한 결과 문제를 통과했습니다.

<img width="1471" height="129" alt="Image" src="https://github.com/user-attachments/assets/7327877b-1e41-4f56-a623-2360b525d3c9" />

- **정답 판정**: 제출 결과, 문제에서 요구하는 비즈니스 로직(둘 다 커야 등수가 밀림)이 정확히 구현되었음을 확인했습니다.
    
- **성능적 아쉬움**: 하지만 실행 시간(200ms)이 데이터 양에 비해 다소 높게 측정 되었습니다. 이는 `Scanner`가 내부적으로 사용하는 정규식 파싱 오버헤드로 인한 것으로 분석됩니다.
    
- **개선 방향**: 실무 환경이나 데이터 규모가 커질 상황을 대비하여, 입출력 속도를 최적화 할 수 있는 `BufferedReader` 기반의 리팩토링이 필요함을 인지했습니다.

2-2. 성능 개선(BufferedReader)

- 기존의 Scanner를 사용한 코드에서 BufferedReader로 변경한 코드는 아래와 같습니다.

```
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int n = Integer.parseInt(br.readLine());
		// 인원수 배열
		int[][]person = new int[n][2];
		
		// 반복문으로 사람의 키와 몸무게를 넣기.
		for(int i=0;i<n;i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			person[i][0] = Integer.parseInt(st.nextToken()); // 키
			person[i][1] = Integer.parseInt(st.nextToken()); // 몸무게
		}
		
		//이중 반복문을 돌리면서 랭킹을 정하기.
		//내부 반복문에서 키와 몸무게가 같으면 continue
		//키나 몸무게 둘 중 하나만 높으면 중복 랭킹으로 하기
		StringBuilder sb = new StringBuilder();
		
		for(int j=0; j<person.length;j++) {
			int rank =1;
			for(int k=0;k<person.length;k++) {
				if(j==k) {
					continue;
				}
				if(person[j][0]<person[k][0]&&person[j][1]<person[k][1]) {
					rank++;
				}
			}
			sb.append(rank).append(" ");
		}
		System.out.println(sb.toString().trim());
	}
```

수정을 한 코드를 제출한 결과는 아래의 사진과 같습니다.

<img width="1473" height="241" alt="Image" src="https://github.com/user-attachments/assets/244b95c1-dab3-4389-9329-54134d18d673" />

기존의 Scanner로 사용했을 때와 BufferedReader로 비교를 했을 때의 수치는 다음과 같습니다. 

- **Scanner**: 18,304 KB / 200 ms
- **BufferedReader**: 14,252 KB / 104 ms
- **결과**: 입출력 방식 개선만으로 **실행 시간을 약 48% 단축**하고 **메모리를 약 4MB 절약**한 것을 알 수가  있습니다.

3.타인 코드 분석 및 리팩토링

문제를 해결한 뒤 백준의 고득점자 코드들을 분석하며 다음과 같은 인사이트를 얻었습니다.

- **상위권 코드 (성능 최적화):** `BufferedReader`를 넘어 `System.in.read()` 등 바이트 단위 처리를 통해 80~90ms대의 성능을 내는 것을 확인했습니다. 또한, 반복문 내에서 출력을 모아 한 번에 내보내는 `StringBuilder`의 중요성을 재확인했습니다.

- **중위권 코드 (가독성과 설계):** 단순히 2차원 배열(`int[][]`)을 쓰는 것이 아니라, `Person` 클래스를 정의하여 `weight`, `height`와 같은 직관적인 필드명을 사용하는 '객체 지향적' 접근이 많았습니다. 이는 실무 환경에서의 유지 보수성과 협업을 고려한 설계임을 배웠습니다.

**객체 지향적 리팩토링 및 트러블 슈팅** 리뷰어의 피드백을 수용하여 사람을 하나의 '객체'로 관리하도록 코드를 개선했습니다.

- **트러블 슈팅:** 리팩토링 과정에서 `The type Person is already defined`라는 에러가 발생했습니다. 이는 동일 패키지 내에 중복된 클래스 명이 존재하여 발생한 명명 충돌(Naming Collision)임을 파악하였고, 클래스 구조를 독립적으로 선언하여 해결했습니다.
    
- **리팩토링 코드:** `ArrayList<Person>`을 사용하여 데이터를 구조화하고, 향후 속성(이름, 나이 등)이 추가되더라도 대응하기 쉬운 유연한 구조로 변경했습니다.

개선을 한 코드는 아래와 같습니다. 

```
//데이터 구조화: 객체 지향적 접근
class DungchiPerson {
    int weight;
    int height;

    public DungchiPerson(int weight, int height) {
        this.weight = weight;
        this.height = height;
    }
}

public class Main {
	
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int n = Integer.parseInt(br.readLine());
		// 배열 대신 객체 리스트 사용
        List<DungchiPerson> list = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            list.add(new DungchiPerson(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken())));
        }

        StringBuilder sb = new StringBuilder();
        
        for (DungchiPerson p1 : list) {
            int rank = 1;
            for (DungchiPerson p2 : list) {
                // 자신과의 비교는 제외하며, 두 조건이 모두 클 때만 등수 가산
                if (p1 == p2) continue;
                if (p1.weight < p2.weight && p1.height < p2.height) {
                    rank++;
                }
            }
            sb.append(rank).append(" ");
        }
		System.out.println(sb.toString().trim());
	}
}
```

위의 코드를 기반으로 해서 제출한 결과는 아래와 같습니다.

<img width="1450" height="242" alt="Image" src="https://github.com/user-attachments/assets/ce8d936a-fd6b-4122-b93a-ecf2dc032b46" />

| 단계        | 주요변경 사항                                | 메모리       | 시간     | 비교                |
| --------- | -------------------------------------- | --------- | ------ | ----------------- |
| 1차(초기)    | Scanner + int[][]                      | 18,304 KB | 200 ms | 구현 중심             |
| 2차 (최적화)  | `BufferedReader` + int[][]             | 14,252 KB | 104 ms | I/O 성능 개선         |
| 3차 (리팩토링) | `BufferedReader` + List<DungchiPerson> | 14,112 KB | 92 ms  | 최종 성능 향상 및 가독성 확보 |

- **성능과 가독성의 양립**: 객체 지향적 설계(`List<Object>`)를 도입하면 메모리 사용량이 늘어날 것이라는 일반적인 우려와 달리, 적절한 입출력 최적화와 결합했을 때 **가독성을 높이면서도 성능을 2배 이상(200ms → 92ms) 개선**할 수 있음을 증명했습니다.
- **유연한 설계**: `p1.weight < p2.weight`와 같이 비즈니스 로직을 직관적으로 표현하여 코드의 의도를 명확히 했으며, 향후 데이터 확장이 용이한 구조를 갖추었습니다.

4.소감

이 문제를 통해 느낀 점은, 문제를 어렵게 만드는 건 알고리즘이 아니라 **불필요한 생각**이라는 것이었습니다.

처음에는 Map 같은 자료구조를 떠올렸지만, 본질은 전수 비교였기에 배열과 이중 반복문으로 충분했습니다. 특히 이번 과정을 통해 **Big-O 관점에서 성능을 예측**하고, **데이터 정합성(Map의 중복 문제)**을 고려하여 자료구조를 선택하는 훈련을 할 수 있었습니다.

또한, 단순히 '맞았습니다'에 그치지 않고 타인의 코드를 분석하며 **'성능'과 '가독성'이라는 두 마리 토끼**를 잡기 위해 고민하는 과정이 개발자로서 얼마나 중요한지 깨달았습니다.