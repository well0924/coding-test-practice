
## 목차

1. 문제 
2. 문제 해결 과정
3. 소감

1.문제
![[Pasted image 20260103160730.png]]

2.문제 이해

![[Pasted image 20260104024327.png]]

우선 위의 사진은 문제를 보고 손코딩을 한 부분입니다. 이해한 문제의 요구 사항을 정리를 해보면 아래와 같습니다.

- 각 사람은 `(몸무게, 키)` 쌍으로 표현된다.  
- 어떤 사람 A가 사람 B보다 **몸무게도 크고 키도 클 때만** A가 B보다 덩치가 크다고 판단한다.
	- **하나만 크면 인정 안 됨** 
	-  **둘 다 커야 카운트** 

- 모든 사람을 서로 비교해서 **나보다 덩치가 큰 사람이 몇 명인지** 세면 됩니다.
	- 처음 등수는 모두 1로 시작
	- 나보다 덩치 큰 사람이 한 명 발견될 때마다 등수 +1

- 사용할 방법은 Map과 배열을  떠올렸지만 배열을 선택을 했습니다. 
	- 우선 Map을  떠오른 이유는 사람의  키와 몸무게를 보고 즉흥적으로 떠올렸습니다.
	- 하지만 Map의 경우에는 Key는 중복이 있어서는 안되므로 배열을 사용하기로  했습니다.

- 입력값은 N이 50 이하이므로 시간 복잡도에 특별히 고려를 할 필요는 없다고 판단이 들었습니다.

다음과 같은 조건을 토대로 해서 알고리즘의 순서는 다음과 같습니다.

- Scanner 를 사용해서  입력값을 받는다.
- 사람들의 `(몸무게, 키)`를 반복문을 사용해서 배열에 저장
- 바깥 반복문: 기준이 되는 사람 i
- 안쪽 반복문: 비교 대상 사람 j
- 이중  반복문의 안쪽 반복문 내부에 조건문을 추가
  ```
  if (weight[j] > weight[i] && height[j] > height[i])
    rank++
  ```
- 최종적으로 rank를 출력을 한다. 

순서를 토대로 한 알고리즘 순서도는 아래와 같습니다.
![[Pasted image 20260107002847.png]]

최종적으로  작성을 한 코드는 아래와 같습니다.

```
Scanner sc = new Scanner(System.in);
		
		int n = sc.nextInt();
		// 인원수 배열
		int[][]person = new int[n][2];
		
		// 반복문으로 사람의 키와 몸무게를 넣기.
		for(int i=0;i<n;i++) {
			person[i][0] = sc.nextInt(); // 키
			person[i][1] = sc.nextInt(); // 몸무게
		}
		
		//이중 반복문을 돌리면서 랭킹을 정하기.
		//내부 반복문에서 키와 몸무게가 같으면 continue
		//키나 몸무게 둘 중 하나만 높으면 중복 랭킹으로 하기.
		
		for(int j=0; j<person.length;j++) {
			int rank =1;
			for(int k=0;k<person.length;k++) {
				if(j==k) {
					continue;
				}
				if(person[j][0]<person[k][0]&&person[j][1]<person[k][1]) {
					rank++;
				}
			}
			System.out.print(rank + " ");
		}
		sc.close();
	}
```

3.소감

이 문제를 통해 느낀 점은, 문제를 어렵게 만드는 건 알고리즘이 아니라 **불필요한 생각**이라는 것이었습니다. 

 처음에는 Map 같은 자료구조를 떠올렸지만, 문제에서 요구하는 것은 키 기반 조회가 아니라 **모든 대상 간의 단순 비교**였습니다. 결국 조건을 정확히 해석하면 배열과 이중 반복문만으로 충분했다는 것을 알았습니다.

입력 크기가 작을 때는 무리한 최적화보다 **문제 요구사항을 그대로 구현하는 게 가장 정확한 해법**이라는 점을 다시 한 번 확인했습니다.